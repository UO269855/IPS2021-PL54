<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableColumnAdjuster.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">samples-test-dev</a> &gt; <a href="index.source.html" class="el_package">giis.demo.util</a> &gt; <span class="el_source">TableColumnAdjuster.java</span></div><h1>TableColumnAdjuster.java</h1><pre class="source lang-java linenums">package giis.demo.util;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.util.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.table.*;

/**
 *	Class to manage the widths of colunmns in a table (Posted by Rob Camick on November 10, 2008
 *  https://tips4java.wordpress.com/2008/11/10/table-column-adjuster/).
 *
 *  Various properties control how the width of the column is calculated.
 *  Another property controls whether column width calculation should be dynamic.
 *  Finally, various Actions will be added to the table to allow the user
 *  to customize the functionality.
 *
 *  This class was designed to be used with tables that use an auto resize mode
 *  of AUTO_RESIZE_OFF. With all other modes you are constrained as the width
 *  of the columns must fit inside the table. So if you increase one column, one
 *  or more of the other columns must decrease. Because of this the resize mode
 *  of RESIZE_ALL_COLUMNS will work the best.
 */
public class TableColumnAdjuster implements PropertyChangeListener, TableModelListener
{
	private JTable table;
	private int spacing;
	private boolean isColumnHeaderIncluded;
	private boolean isColumnDataIncluded;
	private boolean isOnlyAdjustLarger;
	private boolean isDynamicAdjustment;
	private Map&lt;TableColumn, Integer&gt; columnSizes = new HashMap&lt;TableColumn, Integer&gt;();

	/*
	 *  Specify the table and use default spacing
	 */
	public TableColumnAdjuster(JTable table)
	{
		this(table, 6);
	}

	/*
	 *  Specify the table and spacing
	 */
	public TableColumnAdjuster(JTable table, int spacing)
	{
		this.table = table;
		this.spacing = spacing;
		setColumnHeaderIncluded( true );
		setColumnDataIncluded( true );
		setOnlyAdjustLarger( false );
		setDynamicAdjustment( false );
		installActions();
	}

	/*
	 *  Adjust the widths of all the columns in the table
	 */
	public void adjustColumns()
	{
		TableColumnModel tcm = table.getColumnModel();

		for (int i = 0; i &lt; tcm.getColumnCount(); i++)
		{
			adjustColumn(i);
		}
	}

	/*
	 *  Adjust the width of the specified column in the table
	 */
	public void adjustColumn(final int column)
	{
		TableColumn tableColumn = table.getColumnModel().getColumn(column);

		if (! tableColumn.getResizable()) return;

		int columnHeaderWidth = getColumnHeaderWidth( column );
		int columnDataWidth   = getColumnDataWidth( column );
		int preferredWidth	= Math.max(columnHeaderWidth, columnDataWidth);

		updateTableColumn(column, preferredWidth);
	}

	/*
	 *  Calculated the width based on the column name
	 */
	private int getColumnHeaderWidth(int column)
	{
		if (! isColumnHeaderIncluded) return 0;

		TableColumn tableColumn = table.getColumnModel().getColumn(column);
		Object value = tableColumn.getHeaderValue();
		TableCellRenderer renderer = tableColumn.getHeaderRenderer();

		if (renderer == null)
		{
			renderer = table.getTableHeader().getDefaultRenderer();
		}

		Component c = renderer.getTableCellRendererComponent(table, value, false, false, -1, column);
		return c.getPreferredSize().width;
	}

	/*
	 *  Calculate the width based on the widest cell renderer for the
	 *  given column.
	 */
	private int getColumnDataWidth(int column)
	{
		if (! isColumnDataIncluded) return 0;

		int preferredWidth = 0;
		int maxWidth = table.getColumnModel().getColumn(column).getMaxWidth();

		for (int row = 0; row &lt; table.getRowCount(); row++)
		{
			preferredWidth = Math.max(preferredWidth, getCellDataWidth(row, column));

			//  We've exceeded the maximum width, no need to check other rows

			if (preferredWidth &gt;= maxWidth)
				break;
		}

		return preferredWidth;
	}

	/*
	 *  Get the preferred width for the specified cell
	 */
	private int getCellDataWidth(int row, int column)
	{
		//  Inovke the renderer for the cell to calculate the preferred width

		TableCellRenderer cellRenderer = table.getCellRenderer(row, column);
		Component c = table.prepareRenderer(cellRenderer, row, column);
		int width = c.getPreferredSize().width + table.getIntercellSpacing().width;

		return width;
	}

	/*
	 *  Update the TableColumn with the newly calculated width
	 */
	private void updateTableColumn(int column, int width)
	{
		final TableColumn tableColumn = table.getColumnModel().getColumn(column);

		if (! tableColumn.getResizable()) return;

		width += spacing;

		//  Don't shrink the column width

		if (isOnlyAdjustLarger)
		{
			width = Math.max(width, tableColumn.getPreferredWidth());
		}

		columnSizes.put(tableColumn, new Integer(tableColumn.getWidth()));

		table.getTableHeader().setResizingColumn(tableColumn);
		tableColumn.setWidth(width);
	}

	/*
	 *  Restore the widths of the columns in the table to its previous width
	 */
	public void restoreColumns()
	{
		TableColumnModel tcm = table.getColumnModel();

		for (int i = 0; i &lt; tcm.getColumnCount(); i++)
		{
			restoreColumn(i);
		}
	}

	/*
	 *  Restore the width of the specified column to its previous width
	 */
	private void restoreColumn(int column)
	{
		TableColumn tableColumn = table.getColumnModel().getColumn(column);
		Integer width = columnSizes.get(tableColumn);

		if (width != null)
		{
			table.getTableHeader().setResizingColumn(tableColumn);
			tableColumn.setWidth( width.intValue() );
		}
	}

	/*
	 *	Indicates whether to include the header in the width calculation
	 */
	public void setColumnHeaderIncluded(boolean isColumnHeaderIncluded)
	{
		this.isColumnHeaderIncluded = isColumnHeaderIncluded;
	}

	/*
	 *	Indicates whether to include the model data in the width calculation
	 */
	public void setColumnDataIncluded(boolean isColumnDataIncluded)
	{
		this.isColumnDataIncluded = isColumnDataIncluded;
	}

	/*
	 *	Indicates whether columns can only be increased in size
	 */
	public void setOnlyAdjustLarger(boolean isOnlyAdjustLarger)
	{
		this.isOnlyAdjustLarger = isOnlyAdjustLarger;
	}

	/*
	 *  Indicate whether changes to the model should cause the width to be
	 *  dynamically recalculated.
	 */
	public void setDynamicAdjustment(boolean isDynamicAdjustment)
	{
		//  May need to add or remove the TableModelListener when changed

		if (this.isDynamicAdjustment != isDynamicAdjustment)
		{
			if (isDynamicAdjustment)
			{
				table.addPropertyChangeListener( this );
				table.getModel().addTableModelListener( this );
			}
			else
			{
				table.removePropertyChangeListener( this );
				table.getModel().removeTableModelListener( this );
			}
		}

		this.isDynamicAdjustment = isDynamicAdjustment;
	}
//
//  Implement the PropertyChangeListener
//
	public void propertyChange(PropertyChangeEvent e)
	{
		//  When the TableModel changes we need to update the listeners
		//  and column widths

		if (&quot;model&quot;.equals(e.getPropertyName()))
		{
			TableModel model = (TableModel)e.getOldValue();
			model.removeTableModelListener( this );

			model = (TableModel)e.getNewValue();
			model.addTableModelListener( this );
			adjustColumns();
		}
	}
//
//  Implement the TableModelListener
//
	public void tableChanged(TableModelEvent e)
	{
		if (! isColumnDataIncluded) return;

		//  Needed when table is sorted.

		SwingUtilities.invokeLater(new Runnable()
<span class="nc" id="L272">		{</span>
			public void run()
			{
				//  A cell has been updated

<span class="nc" id="L277">				int column = table.convertColumnIndexToView(e.getColumn());</span>

<span class="nc bnc" id="L279" title="All 4 branches missed.">				if (e.getType() == TableModelEvent.UPDATE &amp;&amp; column != -1)</span>
				{
					//  Only need to worry about an increase in width for this cell

<span class="nc bnc" id="L283" title="All 2 branches missed.">					if (isOnlyAdjustLarger)</span>
					{
<span class="nc" id="L285">						int	row = e.getFirstRow();</span>
<span class="nc" id="L286">						TableColumn tableColumn = table.getColumnModel().getColumn(column);</span>

<span class="nc bnc" id="L288" title="All 2 branches missed.">						if (tableColumn.getResizable())</span>
						{
<span class="nc" id="L290">							int width =	getCellDataWidth(row, column);</span>
<span class="nc" id="L291">							updateTableColumn(column, width);</span>
						}
<span class="nc" id="L293">					}</span>

					//	Could be an increase of decrease so check all rows

					else
					{
<span class="nc" id="L299">						adjustColumn( column );</span>
					}
				}

				//  The update affected more than one column so adjust all columns

				else
				{
<span class="nc" id="L307">					adjustColumns();</span>
				}
<span class="nc" id="L309">			}</span>
		});
	}

	/*
	 *  Install Actions to give user control of certain functionality.
	 */
	private void installActions()
	{
		installColumnAction(true,  true,  &quot;adjustColumn&quot;,   &quot;control ADD&quot;);
		installColumnAction(false, true,  &quot;adjustColumns&quot;,  &quot;control shift ADD&quot;);
		installColumnAction(true,  false, &quot;restoreColumn&quot;,  &quot;control SUBTRACT&quot;);
		installColumnAction(false, false, &quot;restoreColumns&quot;, &quot;control shift SUBTRACT&quot;);

		installToggleAction(true,  false, &quot;toggleDynamic&quot;,  &quot;control MULTIPLY&quot;);
		installToggleAction(false, true,  &quot;toggleLarger&quot;,   &quot;control DIVIDE&quot;);
	}

	/*
	 *  Update the input and action maps with a new ColumnAction
	 */
	private void installColumnAction(
		boolean isSelectedColumn, boolean isAdjust, String key, String keyStroke)
	{
		Action action = new ColumnAction(isSelectedColumn, isAdjust);
		KeyStroke ks = KeyStroke.getKeyStroke( keyStroke );
		table.getInputMap().put(ks, key);
		table.getActionMap().put(key, action);
	}

	/*
	 *  Update the input and action maps with new ToggleAction
	 */
	private void installToggleAction(
		boolean isToggleDynamic, boolean isToggleLarger, String key, String keyStroke)
	{
		Action action = new ToggleAction(isToggleDynamic, isToggleLarger);
		KeyStroke ks = KeyStroke.getKeyStroke( keyStroke );
		table.getInputMap().put(ks, key);
		table.getActionMap().put(key, action);
	}

	/*
	 *  Action to adjust or restore the width of a single column or all columns
	 */
	class ColumnAction extends AbstractAction
	{
		private boolean isSelectedColumn;
		private boolean isAdjust;

		public ColumnAction(boolean isSelectedColumn, boolean isAdjust)
<span class="nc" id="L360">		{</span>
<span class="nc" id="L361">			this.isSelectedColumn = isSelectedColumn;</span>
<span class="nc" id="L362">			this.isAdjust = isAdjust;</span>
<span class="nc" id="L363">		}</span>

		@Override
		public void actionPerformed(ActionEvent e)
		{
			//  Handle selected column(s) width change actions

<span class="nc bnc" id="L370" title="All 2 branches missed.">			if (isSelectedColumn)</span>
			{
<span class="nc" id="L372">				int[] columns = table.getSelectedColumns();</span>

<span class="nc bnc" id="L374" title="All 2 branches missed.">				for (int i = 0; i &lt; columns.length; i++)</span>
				{
<span class="nc bnc" id="L376" title="All 2 branches missed.">					if (isAdjust)</span>
<span class="nc" id="L377">						adjustColumn(columns[i]);</span>
					else
<span class="nc" id="L379">						restoreColumn(columns[i]);</span>
				}
<span class="nc" id="L381">			}</span>
			else
			{
<span class="nc bnc" id="L384" title="All 2 branches missed.">				if (isAdjust)</span>
<span class="nc" id="L385">					adjustColumns();</span>
				else
<span class="nc" id="L387">					restoreColumns();</span>
			}
<span class="nc" id="L389">		}</span>
	}

	/*
	 *  Toggle properties of the TableColumnAdjuster so the user can
	 *  customize the functionality to their preferences
	 */
	class ToggleAction extends AbstractAction
	{
		private boolean isToggleDynamic;
		private boolean isToggleLarger;

		public ToggleAction(boolean isToggleDynamic, boolean isToggleLarger)
<span class="nc" id="L402">		{</span>
<span class="nc" id="L403">			this.isToggleDynamic = isToggleDynamic;</span>
<span class="nc" id="L404">			this.isToggleLarger = isToggleLarger;</span>
<span class="nc" id="L405">		}</span>

		@Override
		public void actionPerformed(ActionEvent e)
		{
<span class="nc bnc" id="L410" title="All 2 branches missed.">			if (isToggleDynamic)</span>
			{
<span class="nc bnc" id="L412" title="All 2 branches missed.">				setDynamicAdjustment(! isDynamicAdjustment);</span>
<span class="nc" id="L413">				return;</span>
			}

<span class="nc bnc" id="L416" title="All 2 branches missed.">			if (isToggleLarger)</span>
			{
<span class="nc bnc" id="L418" title="All 2 branches missed.">				setOnlyAdjustLarger(! isOnlyAdjustLarger);</span>
<span class="nc" id="L419">				return;</span>
			}
<span class="nc" id="L421">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>